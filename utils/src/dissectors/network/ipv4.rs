use nom::bytes::complete::take;
use nom::combinator::peek;
use nom::number::complete::be_u16;
use nom::IResult;

use super::ip_proto;
use crate::dissectors::{Error, Protocol};

pub fn dissect(data: &[u8]) -> IResult<(usize, Option<Protocol>), &[u8], Error<&[u8]>> {
    let ip_vhl = data[0];
    let ip_version = ip_vhl >> 4;

    if ip_version != 4 {
        return Err(nom::Err::Error(Error::CorruptPacket(
            "Corrupted IPV4 packet, ip vesrion not match",
        )));
    }

    let ip_hdr_len = ((ip_vhl & 0x0f) * 4) as usize;
    if ip_hdr_len < 4 * 5 {
        // 如果报文中的IP头长度小于20字节或报文长度小于报文中声明的IP头长度, 数据包有错误
        return Err(nom::Err::Error(Error::CorruptPacket(
            "Corrupt IPV4 packet, ip header too short ",
        )));
    }

    let (data, _) = peek(take(2usize))(data)?;
    let (_, total_len) = peek(be_u16)(&data[2..])?;
    let (_, data) = take(total_len as usize)(data)?;
    let (remain, data) = take(ip_hdr_len)(data)?;

    let ip_proto = data[9];

    let protocol = match ip_proto {
        ip_proto::ICMP => Protocol::ICMP,
        ip_proto::IGMP => Protocol::IGMP,
        ip_proto::IPV4 => Protocol::IPV4,
        ip_proto::TCP => Protocol::TCP,
        ip_proto::UDP => Protocol::UDP,
        ip_proto::ESP => Protocol::ESP,
        ip_proto::IPV6 => Protocol::IPV6,
        ip_proto::GRE => Protocol::GRE,
        ip_proto::SCTP => Protocol::SCTP,
        _ => return Err(nom::Err::Error(Error::UnsupportIPProtocol(ip_proto))),
    };

    Ok(((ip_hdr_len, Some(protocol)), remain))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ok() {
        let buf = [
            0x45, 0x00, 0x00, 0x64, 0x00, 0x0a, 0x00, 0x00, 0xff, 0x01, 0xa5, 0x6a, 0x0a, 0x01,
            0x02, 0x01, 0x0a, 0x22, 0x00, 0x01, // ipv4
            0x08, 0x00, 0x3a, 0x77, 0x0a, 0x39, 0x06, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
            0x33, 0x50, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, //icmp
        ];
        let result = dissect(&buf);
        assert!(matches!(result, Ok(_)));
    }

    #[test]
    fn test_err_pkt_too_short() {
        let buf = [0x45];
        let result = dissect(&buf);
        assert!(matches!(result, Err(nom::Err::Error(Error::Nom(_, _)))));
    }

    #[test]
    fn test_err_not_ipv4() {
        let buf = [
            0x65, 0x00, 0x00, 0x64, 0x00, 0x0a, 0x00, 0x00, 0xff, 0x01, 0xa5, 0x6a, 0x0a, 0x01,
            0x02, 0x01, 0x0a, 0x22, 0x00, 0x01,
        ];
        let result = dissect(&buf);
        assert!(matches!(
            result.unwrap_err(),
            nom::Err::Error(Error::CorruptPacket(_))
        ));
    }

    #[test]
    fn test_err_ip_hdr_len_too_short() {
        let buf = [
            0x44, 0x00, 0x00, 0x64, 0x00, 0x0a, 0x00, 0x00, 0xff, 0x01, 0xa5, 0x6a, 0x0a, 0x01,
            0x02, 0x01, 0x0a, 0x22, 0x00, 0x01,
        ];
        let result = dissect(&buf);
        assert!(matches!(
            result.unwrap_err(),
            nom::Err::Error(Error::CorruptPacket(_))
        ));
    }

    #[test]
    fn test_err_buf_len_shorter_than_ip_hdr_len() {
        let buf = [
            0x46, 0x00, 0x00, 0x64, 0x00, 0x0a, 0x00, 0x00, 0xff, 0x01, 0xa5, 0x6a, 0x0a, 0x01,
            0x02, 0x01, 0x0a, 0x22, 0x00, 0x01,
        ];
        let result = dissect(&buf);
        assert!(matches!(result, Err(nom::Err::Error(Error::Nom(_, _)))));
    }

    #[test]
    fn test_err_payload_too_short() {
        let buf = [
            0x45, 0x00, 0x00, 0x64, 0x00, 0x0a, 0x00, 0x00, 0xff, 0x01, 0xa5, 0x6a, 0x0a, 0x01,
            0x02, 0x01, 0x0a, 0x22, 0x00, 0x01,
        ];
        let result = dissect(&buf);
        assert!(matches!(result, Err(nom::Err::Error(Error::Nom(_, _)))));
    }

    #[test]
    fn test_err_unsupport_protocol() {
        let buf = [
            0x45, 0x00, 0x00, 0x64, 0x00, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xa5, 0x6a, 0x0a, 0x01,
            0x02, 0x01, 0x0a, 0x22, 0x00, 0x01, //ipv4
            0x08, 0x00, 0x3a, 0x77, 0x0a, 0x39, 0x06, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
            0x33, 0x50, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, // icmp
        ];
        let result = dissect(&buf);
        assert!(matches!(
            result.unwrap_err(),
            nom::Err::Error(Error::UnsupportIPProtocol(_))
        ));
    }
}
