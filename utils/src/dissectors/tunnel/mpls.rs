use nom::bytes::complete::take;
use nom::IResult;

#[cfg(feature = "heuristic-mpls")]
use super::{ppp, pppoe};
use super::{Error, Protocol};
#[cfg(feature = "heuristic-mpls")]
use crate::dissectors::link::ethernet;
#[cfg(feature = "heuristic-mpls")]
use crate::dissectors::network::{ipv4, ipv6};

pub fn dissect(data: &[u8]) -> IResult<(usize, Option<Protocol>), &[u8], Error> {
    let mut len = 0;
    let (mut remain, data) = take(4usize)(data)?;
    len += 4;

    let mut mpls_stack_bottom = data[2] & 0x1;
    while mpls_stack_bottom != 1 {
        if 4 > remain.len() {
            break;
        }

        let (r, data) = take(4usize)(remain)?;
        len += 4;
        remain = r;
        mpls_stack_bottom = data[2] & 0x1;
    }

    #[cfg(feature = "heuristic-mpls")]
    {
        match ethernet::dissect(remain) {
            Err(e) => eprintln!("{:?}", e),
            Ok(((_, protocol), data)) => {
                match protocol {
                    Some(Protocol::IPV4) => match ipv4::dissect(data) {
                        Ok(_) => return Ok(((len, Some(Protocol::ETHERNET)), remain)),
                        Err(_) => {}
                    },
                    Some(Protocol::IPV6) => match ipv6::dissect(data) {
                        Ok(_) => return Ok(((len, Some(Protocol::ETHERNET)), remain)),
                        Err(_) => {}
                    },
                    Some(Protocol::PPP) => match ppp::dissect(data) {
                        Ok(_) => return Ok(((len, Some(Protocol::ETHERNET)), remain)),
                        Err(_) => {}
                    },
                    Some(Protocol::MPLS) => {
                        todo! {"too much tunnel layers to handle"}
                    }
                    Some(Protocol::PPPOE) => match pppoe::dissect(data) {
                        Ok(_) => return Ok(((len, Some(Protocol::ETHERNET)), remain)),
                        Err(_) => {}
                    },
                    Some(Protocol::ARP) => return Ok(((len, Some(Protocol::ETHERNET)), remain)),
                    Some(Protocol::VLAN) => {
                        todo! {"too much tunnel layers to handle"}
                    }
                    _ => {} // do nothing, unsupported protocol
                };
            }
        };
    }

    match remain[0] >> 4 {
        // PW Ethernet Control Word
        0b0000 => {
            let (data, _) = take(4usize)(remain)?;
            len += 4;
            Ok(((len, Some(Protocol::ETHERNET)), data))
        }
        0b0100 => Ok(((len, Some(Protocol::IPV4)), remain)),
        0b0110 => Ok(((len, Some(Protocol::IPV6)), remain)),
        _ => Err(nom::Err::Error(Error::CorruptPacket(
            "Corrupted MPLS packet, at mpls stack bottom but no valid network layer found",
        ))),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn single_layer_mpls_with_ipv4() {
        let buffer = [
            0x00, 0x01, 0xd1, 0xff, // mpls
            0x45, 0x00, 0x00, 0x64, 0x00, 0x0a, 0x00, 0x00, 0xff, 0x01, 0xa5, 0x6a, 0x0a, 0x01,
            0x02, 0x01, 0x0a, 0x22, 0x00, 0x01, // ipv4
            0x08, 0x00, 0x3a, 0x77, 0x0a, 0x39, 0x06, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
            0x33, 0x50, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, // icmp
        ];

        let result = dissect(&buffer);
        assert!(result.is_ok());
        let ((len, protocol), data) = result.unwrap();
        assert_eq!(len, 4);
        assert_eq!(protocol, Some(Protocol::IPV4));
        assert_eq!(data.len(), buffer.len() - 4);
    }

    #[test]
    fn single_layer_mpls_with_ipv6() {
        let buffer = [
            0x00, 0x01, 0xd1, 0xff, // mpls
            0x60, 0x0c, 0x6b, 0x7b, 0x00, 0xb8, 0x11, 0xff, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x08, 0xfa, 0x70, 0x46, 0xe8, 0x42, 0x04, 0xff, 0x02, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb, // ipv6
            0x14, 0xe9, 0x14, 0xe9, 0x00, 0xb8, 0x5a, 0x88, //udp
            0xa6, 0xea, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x73,
            0x77, 0x2d, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x05, 0x6f, 0x62, 0x64, 0x65, 0x76,
            0x02, 0x61, 0x74, 0x00, 0x00, 0x01, 0x00, 0x01, // dns,
        ];

        let result = dissect(&buffer);
        assert!(result.is_ok());
        let ((len, protocol), data) = result.unwrap();
        assert_eq!(len, 4);
        assert_eq!(data.len(), buffer.len() - 4);
    }

    #[test]
    #[cfg(feature = "heuristic-mpls")]
    fn double_layer_mpls_with_ethernet() {
        let buffer = [
            0x00, 0x01, 0x20, 0xfe, // mpls
            0x00, 0x01, 0x01, 0xff, // mpls
            0x01, 0x80, 0xc2, 0x00, 0x00, 0x00, 0xcc, 0x04, 0x0d, 0x5c, 0xf0, 0x00, 0x08,
            0x06, // Ethernet
            0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x00, 0x50, 0x79, 0x66, 0x68, 0x00,
            0xc0, 0xa8, 0x00, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xa8, 0x00,
            0x14, // ARP
        ];

        let result = dissect(&buffer);
        assert!(result.is_ok());
        let ((len, protocol), data) = result.unwrap();
        assert_eq!(len, 8);
        assert_eq!(protocol, Some(Protocol::ETHERNET));
        assert_eq!(data.len(), buffer.len() - 8);
    }

    #[test]
    #[cfg(feature = "heuristic-mpls")]
    fn ethernet_over_mpls_with_pw_control_word() {
        let buffer = [
            0x00, 0x01, 0x20, 0xfe, // mpls
            0x00, 0x01, 0x01, 0xff, // mpls
            0x00, 0x00, 0x00, 0x00, // PW Ethernet Control Word
            0x01, 0x80, 0xc2, 0x00, 0x00, 0x00, 0xcc, 0x04, 0x0d, 0x5c, 0xf0, 0x00, 0x00,
            0x26, // Ethernet
            0x42, 0x42, 0x03, // Logical-Link Control
            0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0xcc, 0x04, 0x0d, 0x5c, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x80, 0x00, 0xcc, 0x04, 0x0d, 0x5c, 0x00, 0x00, 0x80, 0x01, 0x00,
            0x00, 0x14, 0x00, 0x02, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, // Spanning Tree Protocol
        ];

        let result = dissect(&buffer);
        assert!(result.is_ok());
        let ((len, protocol), data) = result.unwrap();
        assert_eq!(len, 12);
        assert_eq!(protocol, Some(Protocol::ETHERNET));
        assert_eq!(data.len(), buffer.len() - 12);
    }

    #[test]
    #[cfg(feature = "heuristic-mpls")]
    fn ethernet_over_mpls_without_pw_contrtol_word() {
        let buffer = [
            0x00, 0x01, 0x01, 0xff, // mpls
            0x01, 0x80, 0xc2, 0x00, 0x00, 0x00, 0xcc, 0x04, 0x0d, 0x5c, 0xf0, 0x00, 0x08,
            0x00, // Ethernet
            0x45, 0x00, 0x00, 0x64, 0x00, 0x0a, 0x00, 0x00, 0xff, 0x01, 0xa5, 0x6a, 0x0a, 0x01,
            0x02, 0x01, 0x0a, 0x22, 0x00, 0x01, // ipv4
            0x08, 0x00, 0x3a, 0x77, 0x0a, 0x39, 0x06, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
            0x33, 0x50, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, // icmp
        ];

        let result = dissect(&buffer);
        assert!(result.is_ok());
        let ((len, protocol), data) = result.unwrap();
        assert_eq!(len, 4);
        assert_eq!(protocol, Some(Protocol::ETHERNET));
        assert_eq!(data.len(), buffer.len() - 4);
    }
}
